begin(){
powerUp();
delay(500);
}





Почему-то никто не использует одну из главных фишек nrf24l01+ версии. Динамическую длину посылки. 
Всего то нужно radio.enableDynamicPayloads() в setup (у приемника и передатчика) 
После получения посылки на приемнике, перед чтением буфера getDynamicPayloadSize() вернет размер полученной посылки. 
Кстати приемник может быть настроенным по старинке на работу со статическим буфером и посылки будут доходить.





И ещё, в результате сегодняшних экспериментов с библиотекой TMRh20 вылезла некоторая особенность.
 Если мы в настройках ставим radio.setChannel( i) и radio.setPALevel(RF24_PA_MAX); (где i - любой канал), 
 то передатчик ничего не передаёт. Нужно либо ставить скорость на HIGH, 
 либо убирать настройку принудительно канала и оставлять по-умолчанию. 
 Что интересно, если такие настройки radio.setChannel( i) и radio.setPALevel(RF24_PA_MAX); 
 ставить на приём, то приёмник отлично работает.

P.S. хотя особой разницы между HIGH и MAX не заметил (проверял дальность)



=========================================
=======постоянный адрес переменных ==========
=======для отправки и приема=================
==========================================
пляска с бубнами лишена смысла по той причине, что мы проглядели в библиотеке одну важную вещь, а именно: 
необходимость иметь постоянный адрес переменных для отправки и приема.
И здесь получается интересная ситуация: кто-то объявляет такие переменные глобальными, кто-то локальными, 
а у кого- то в передатчике и приемнике и так и так.
И получается большое число комбинаций глюков.
В общем, наблюдая за Вашим кодом и сравнивая его с референсным увидел лишь одно отличие 
- переменные примеров являются статическими.
С точки зрения языка С конкретных примеров это не имеет особого смысла. Все должно и так работать. 
Но если посмотреть внимательно библиотеку, то в передающих и принимающих функциях адрес переменных указан как const. 
А такой адрес возникает, по-моему, если переменная объявлена или глобальной или локальной, но static.





Достаточно лишь stopListening();

void RF24::stopListening(void)
{
ce(LOW);
flush_tx();
flush_rx();
}





Впечатление, что какой-то буфер не чистится (помимо того, который Вы принудительно у себя чистите через flush_tx). 
В итоге: добавил непосредственно перед write:

Код (Text):
radio.startListening();
radio.stopListening();





1. Вы попытались работать с самым сложным вариантом. Уберите все, что касается AckPayload и попробуйте добиться стабильной работы. 
Возможно: int command = random(1,4) заменить на int command = (int) random(1,4); в коде передатчика, и int dataIn на static int dataIn в коде приемника.
2. Что касается AckPayload, попробуйте заменить uint32_t message на static uint32_t message в скетче передатчика, 
а также uint32_t message на static uint32_t message в скетче приемника.


setPayloadSize (uint8_t size);



